
// need SText module 
SText = require "../stext";

class print:
	/*
		black='\033[30m' red='\033[31m' green='\033[32m' orange='\033[33m'
		blue='\033[34m' purple='\033[35m' cyan='\033[36m' lightgrey='\033[37m'
	 	darkgrey='\033[90m' lightred='\033[91m' lightgreen='\033[92m' yellow='\033[93m'
		lightcyan='\033[94m' pink='\033[95m' lightblue='\033[96m'
	*/
	/*
		clear terminal '\033c'
	 */
	color_map = {
		r : '\033[91m', // light red
		b : '\033[96m', // light blue
		g : '\033[92m', // light green
		c : '\033[36m', // cyan
		d : '\033[90m', // dark grey
		w : '\033[37m'  // light grey
	};
	color_patt     = new RegExp( "(\#?)<("+ Object.keys(color_map).join('|') +"):" );
	color_code     = new RegExp('\033\\[\\d+m','g');
	set_patt       = new RegExp( "(^|\\b|\#|\\s)<(\\$|cp|ac|ar|al|bd):" );

	print_ers     = [];
	print_history = [];
	print_content = [];
	print_scope   = {};
	print_state   = false;
	stdout_write  = process.stdout.write;
	print_write   = function():
						text = Array::join.call(arguments, ' ');
						print_content.push( text );
						stdout_write.call(process.stdout, text);

	// process.stdout.write  = print_write;

	stdout_width       = process.stdout.columns || 0;
	print_maxwidth     = 120;
	print_indent       = '';

	constructor():
		if @.constructor != print:
			if @.stdout.apply( @, arguments):
				print_write('\n');

	static isTerminal = !!stdout_width;

	static indent():
		print_indent += '\t';
		return @;

	static back():
		print_indent = print_indent.slice(0, -1);
		return @;

	static debuger():
		print('[Print Debuger]\n<stack>');

	static bd():
		text = @.toText.apply( @, arguments);
		print_write( formatBorder(text, null, countWidth( text ) ) );
		print_write('\n');

	static stdout():
		if text = @.toText.apply(@, arguments):
			if print_state:
				@.refresh();
			if /<\$:\w+:>/.test( text ) && print_history.indexOf(text) != -1:
				return false;
			print_history.push( text )
			text = text.replace(/<\$:(\w+):>/g, ($, $1) => return print_scope[$1] || $);
			if print_indent:
				text = text.replace(/^/mg, print_indent);
			print_write( text );
		return true;

	static clear():
		if @.isTerminal:
			content       = print_content.join('');
			move          = Math.max(content.split('\n').length-1, 0);
			print_write('\033['+move+'A'+'\033[K');
			print_content = [];
		else:
			print('<**>');

	static refresh():
		if arguments.length:
			changeVariable.apply(@, arguments);
		print_state = false;
		if print_history.length:
			if arguments.length:
				print_history.push( @.toText.apply(@, arguments) );
			text = print_history.join( '' );
			text = text.replace(/<\$:(\w+):>/g, ($, $1) => return print_scope[$1] || $);
			@.clear();
			print_write( text );

	static toText():
		texts = [];
		for arg => arguments:
			if !arg:
				texts.push( arg+'' )
				continue;
			type = arg.className || className(arg);
			if type == 'String' || type == 'Number' || type == 'Boolean':
				texts.push( arg );
				continue;
			if type in print_ers:
				texts.push( print_ers[type].call(@, arg)+'' ); 
				continue;
			texts.push( formatObject( arg ) );
		text = texts.join(' ');
		return  /<[\w\W]*>/.test(text) ? @.format(text) : text;

	static stacks(err):
		err    = err || new Error();
		list   = [];

		if err as 'function':
			t = 15;
			fn = err;
			while fn && t--:
				fnname = funcName( fn, true );
				if list.indexOf(fnname) != -1:
					break;
				list.push( fnname || '???' );
				fn = fn.caller;
			return list;


		stacks = err.stack.split('\n');		
		for i = 1 -> stacks:
			if ref = stackInfo(stacks[i]):
				list.push(ref);
		list = list.filter( ($) => return !!$ );
		list.className = 'Stacks';
		return list;

	static format(text, width = 60):
		text  = formatDebug(text);
		text  = formatColor(text);
		text  = formatSet( text, Math.max(width, countWidth( text )));
		text  = formatFill( text, Math.max(width, countWidth( text )));
		return text;

	static fragment(text, code, line, col, file):
		if arguments.length == 1 && text as 'object':
			file = text.fileName || text.file;
			col  = text.columnNumber || text.column || text.col;
			line = text.lineNumber || text.line || text.number;
			code = text.code || text.text;
			text = null;

		if arguments.length == 4:
			file = col;
		if !text:
			text = SText.readFile(file);
		if /\n/.test(text):
			if arguments.length == 4:
				[text, line, col] = SText.indexLine(text, line);
			else if !line && code:
				[text, line, col] = SText.indexLine(text, text.indexOf(code));
			else:
				text = text.split('\n')[line - 1];
		if !code && col:
			code =  SText.split( text.substr( col-1 ), /[\;\)\]\}\,]/)[0];
		return formatFragment(text, code, line, col, file);

	static register(name, printer):
		if printer:
			print_ers[name] = printer;

	function formatObject(obj, _cache = [obj]):
		texts = [];
		is_arr = Array.isArray(obj);
		for key, value in obj:
			if value as 'object' && value:
				if _cache.indexOf(value) == -1:
					_cache.push( value );
					value = formatObject(value, _cache);
				else:
					value = '[circular]';
			else if value as 'string':
				value = '"'+SText(value, '"')+'"';
			if is_arr:
				texts.push( value );
			else:
				texts.push( '"'+key+'" : '+ value );

		if texts.length:
			if texts.length < 2:
				text = texts.join(' ');
			else:
				text = '\n'+texts.join('\n').replace(/^/mg, '\t')+'\n';
		else:
			text = '';
		if is_arr:
			return '['+text+']';
		return '{'+text+'}';

	function formatDebug(text):
		if m = text.match(/<(debug|code|fragment|stack)>/):
			stacks |= print.stacks();
			the = stacks[0];
			switch m[1]:
				case 'debug':
					text = text.replace(/<debug>/g, the.filePoint);
				case 'code':
					text = text.replace(/<code>/g, the.code + '<> at '+the.filePoint);
				case 'fragment':
					line_text = SText.readFile(the.fileName, the.lineNumber);
					text = text.replace(/<fragment>/g, formatFragment( line_text, null, the.lineNumber, the.columnNumber, the.fileName ));
				case 'stack':
					text = text.replace(/<stack>/g, printStacks(stacks));
		return text;

	function formatFragment(text = '', code = '', line = 0, col = 0, file):
		text = text.replace(/\n+$/g, '');
		str = '  '+line+' | '+text+'\\n\n';
		str += str.substr(0, str.length-3-text.length+col).replace(/[^\s]/g, ' ');
		str += '<r:'+SText.copy('^', code.length||1)+':>\n';
		if file:
			str = file+':'+line+':'+col+'\n'+str;
		return str;			

	function formatFill(text, _width):	
		ls = text.split('\n');
		ws = [];
		ds = [];
		for l => ls:
			ms = [];
			ts = [];
			ss = SText.split(l, /<(\~|[^\\w\\s]{2}|\d+)?>/, false);
			for i -> ss:
				if i%2:
					ms.push( ss[i] );
				else:
					if !ws[ts.length] || ss[i].length > ws[ts.length]:
						ws[ts.length] = ss[i].length;
					ts.push( ss[i] );
			ds.push( [ts, ms] );

		W = Math.max( _width, ds.length == 1 || /<~>/.test(text) ? stdout_width - 5 : 0);
		for i -> ws:
			W -= ws[i] || 0;
		if W < 0:
			W = 0;

		texts = [];
		for d => ds:
			ts = d[0];
			ms = d[1];
			sw = Math.floor( W/ms.length );
			for i -> ts:
				texts.push( ts[i] );
				if ms[i]:
					if /<(\d+)>/.test(ms[i]):
						texts.push( SText.copy(' ', (parseInt(RegExp.$1)||0)-ts[i].length) )
					else:
						texts.push( SText.copy(ms[i].length == 4 ? ms[i][1] : ' ', ws[i]-ts[i].length + sw) );
			texts.push('\n');
		texts.pop();
		return texts.join('');

	function formatColor(text):
		texts = [];
		while tmp = formatMatch(text, color_patt):
			if tmp[0]:
				texts.push(tmp[0]);
			tmp[2] = @.format( formatColor( tmp[2] ) );
			if @.isTerminal && tmp[1] in color_map:
				tmp[2] = color_map[tmp[1]] + tmp[2] + '\033[0m';	
			texts.push(tmp[2]);
			text = tmp[3];
		if text:
			texts.push(text);
		text = texts.join('');
		return text;

	function formatSet(text, _width):
		texts = [];
		while tmp = formatMatch(text, set_patt):
			if tmp[0]:
				texts.push(tmp[0]);
			
			switch tmp[1]:
				case 'bd':
					texts.push( formatBorder( tmp[2], tmp[1], _width) )
				case 'ac', 'al', 'ar':
					texts.push( formatAlgin( tmp[2], tmp[1], _width) )
					break;
				case 'cp':
					temp = tmp[2].split(' ');
					texts.push( SText.copy(temp[0], parseInt(temp[1])) );
				case '$':
					temp = tmp[2].split(' ');
					changeVariable( temp[0], temp.slice(1).join(' '));
					texts.push( '<$:'+temp[0]+':>' );
			text = tmp[3];
		if text:
			texts.push(text);
		text = texts.join('');
		return text;

	function formatAlgin(text, type, _width):
		lines = formatSet(text, _width).split('\n');
		for i, line -> lines:
			switch type:
				case 'ac':
					f = Math.floor( (_width-line.length)/2 );
				case 'al':
					f = -1;
				case 'ar':
					f = _width-line.length;
			if f > 0:
				lines[i] = SText.copy(' ', f)+line;
			else if f < 0:
				lines[i] = line.replace(/^\s+/g, '');
		return lines.join('\n');

	function formatBorder(text, type, _width):
		text = formatSet(text, _width);
		text = SText.spaceTab(text);
		width = Math.max(_width - 4, countWidth(text));
		lines = text.split('\n');
		for i, line -> lines:
			lines[i] = '| '+line+SText.copy(' ', width-countWidth(line))+' |';
		return  SText.copy('-', width+4)+'\n'+
				lines.join('\n')+'\n'+
				SText.copy('-', width+4);

	function formatMatch(text, re):
		if m = text.match(re):
			_a = m[1] == '#' ? m.index : m.index + m[1].length;
			a  = m.index;
			ab = SText.indexPair(text, m[0], ':>', a);
			if !ab || ab[0] != a || ab[0]+1 == ab[1]:
				return;
			b  = ab[1];
			s1 = text.substr(0, _a);
			s2 = text.slice( a+m[0].length, b );
			s3 = text.substr( b+2 );
			return [s1, m[2], s2, s3];

	function changeVariable(name, value):
		if name as 'object':
			data = name, _not_refresh = value;
			for name, value in data:
				print_scope[name] = value;
		else:
			print_scope[name] = value;
		print_state = true;

	function countWidth(text):
		return SText.width( clearColor(text) );

	function clearColor(text):
		return text.replace( color_code, '' );

	function className(obj):
		if obj && obj.constructor && obj.constructor.toString:
			return funcName(obj.constructor);

	function funcName(fn, tostr):
		if fn:
			if m = fn.toString().match(/function\s*(\w+)/):
				return m[1];
			if tostr:
				if m = fn.toString().match(/function\s*\(.*(?:\):|\)\{)/):
					return m[0].slice(0, -1);

	function stackInfo( str ):
		if m = str.match(/at (.*?) \((.*?)\)$/):
			if /print\./.test( m[1] ):
				return;
			f = m[2].split(':');
			if __filename == f[0]:
				return;
			info = {
				target       : m[1]
				fileName     : f[0]
				lineNumber   : parseInt(f[1])
				columnNumber : parseInt(f[2])
				
				get filePoint():
					return @.fileName+':'+@.lineNumber+':'+@.columnNumber;

				get code():
					if !@._code:
						if code = SText.readFile( @.fileName, @.lineNumber ):
							@._code = SText.split(code.substr( @.columnNumber -1 ), /[\;\)\]\}\,]/)[0];
						else:
							 @._code = ' ';
					return @.target+' > "'+SText(SText.limit(@._code, 20))+'"';
			};
			return info;

	function printStacks( stacks ):
		texts = [];
		for stack => stacks:
			if typeof stack == 'string':
				texts.push(stack);
			else:
				texts.push(" â€¢ ${stack.target} <~> File \"${stack.fileName}\", line ${stack.lineNumber}" );
		return texts.join('\n');

	@.register('Stacks', printStacks);

module.exports = print;

if require.main == module:
	print process.argv.slice( process.argv.indexOf(__filename)+1 ).join(' ');